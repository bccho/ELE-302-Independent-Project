{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11160\viewh10440\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Programmable Hardware\
\
Motor Control\
\
Phase-magnitude drive requires a PWM signal where the \'93on\'94 time signal drives the motor in the intended direction and the \'93off\'94 time signal brakes the motor. Since the H-bridge circuit as described in section [] defaults to connecting each motor terminal to ground, this can be achieved by simply sending a normal PWM signal to one of the inputs \\texttt\{C1\} or \\texttt\{C2\} and letting the other input remain pulled high by the H-bridge circuit. When the PSoC drives \\texttt\{C1\} low, the left terminal is connected to power and the motor goes forward, and when the PSoC releases \\texttt\{C1\}, the left terminal is pulled back high an the motor brakes. To go in reverse, the PSoC simply needs to drive \\texttt\{C2\} instead of \\texttt\{C1\}.\
\
This, then, breaks the control into two very natural signals, direction and magnitude. The PWM signal controls the magnitude of rotation, and changing which terminal it goes into controls the direction of rotation. We implemented this scheme in the programmable hardware with PWM blocks and demultiplexers (\\textit\{i.e.\}, switches). There is one PWM block per motor, and each PWM block outputs into a demultiplexer which selects between forward and reverse based on a software control signal. The software control signals come from the \\verb\{Control_Reg_Direction\} block. This is the complete picture of the control at a high level, but a couple more additions were required to make it actually work. The final control signal outputs of the PSoC are open drain, so \'93on\'94 corresponds to a low signal and \'93off\'94 corresponds to a high signal. Demuxes output low on all unused inputs, which is the opposite behavior to what is desired, so we had to invert all of the demux outputs to make them default to floating rather than pulling low. This also had the convenient effect of making the high side of the PWM signal correspond to driving the output low, which is what turns the motor on, so on the software side, the duty cycle maps directly to throttle rather than inversely.\
\
Other hardware\
\
The servo that controls the angle of the paddle is directly controlled by a single PWM block, \\verb\{PWM_Servo\}. We continued to use a UART block to communicate with our computers for debugging, and added a second, \\verb\{Serial_Pi\} to communicate with the Raspberry Pi. We also have a master I2C block that manages communication with the accelerometer/gyro chip. There is also a counter block, \\verb\{Counter_Refresh\}, which is used as a refresh timer. It interrupts at a rate of \\SI\{1\}\{\\kilo\\hertz\}. Finally, we have another counter, \\verb\{Counter_Time\}, on a slower clock, that is used to accurately keep track of time.}